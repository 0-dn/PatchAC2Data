#!/usr/bin/python

# patch-ac2-data v1
#
# Copyright (c) 2012 Steve Nygard
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#     THE SOFTWARE.

import struct
import binascii
import time
import math

class AC2Exception(Exception):
    pass

class AC2FileEntry:
    def __init__(self, identifier, offset, size, mtime):
        self.identifier = identifier
        self.offset     = offset
        self.size       = size
        self.mtime      = mtime

    def __str__(self):
        return "AC2FileEntry <identifier: %08x, offset: %08x, size: %08x, mtime: %08x -- %s>" % (self.identifier, self.offset, self.size, self.mtime, time.ctime(self.mtime))

class AC2Directory:
    def __init__(self, dataFile, offset, shouldLoadSubdirectories=False):
        self.offset = offset
        self.subdirectories = []
        self.subdirectoryOffsets = []
        self.files = []

        # 62*4 + 4 + 62*16 = 1244
        buf = dataFile.readDataFromBlocks(offset, 1244)
        count, = struct.unpack_from("<I", buf, 248) # 62*4=248
        self.count = count
        #print "count:", count

        offsets = struct.unpack_from("<62I", buf, 0)
        if shouldLoadSubdirectories:
            for sdo in offsets:
                self.subdirectories.append(AC2Directory(dataFile, sdo, True))

        sdoc = count + 1
        self.subdirectoryOffsets = offsets[:sdoc]
        if 0:
            print "offsets:", ", ".join(["%08x" % offset for offset in self.subdirectoryOffsets])
        for index in range(0, count):
            (identifier, offset, size, mtime) = struct.unpack_from("<4I", buf, 252 + 16 * index)
            #print "%2u: %08x %08x %08x %08x" % (index, identifier, offset, size, mtime)
            fileEntry = AC2FileEntry(identifier, offset, size, mtime)
            #print "%2u: %s" % (index, fileEntry)
            self.files.append(fileEntry)

    def __str__(self):
        return "AC2Directory at %08x, count: %u, subdirectory count: %u, file count: %u" % (self.offset, self.count, len(self.subdirectories), len(self.files))

class AC2DataFile:
    """A simple class to allow data replacement in Asheron's Call 2 data files."""

    def __init__(self, filename):
        self.fileHandle = open(filename, "rb+")
        #print self.fileHandle
        self.fileHandle.seek(0x12c)
        buf = self.fileHandle.read(4*9)
        #print "read buf:", binascii.hexlify(buf)
        magic, blockSize, fileSize, contentType, contentSubtype, firstFreeBlock, lastFreeBlock, freeBlockCount, rootOffset = struct.unpack("<9I", buf);
        if magic != 0x00005442:
            raise AC2Exception("Bad magic number for an AC2 data file")
        self.blockSize      = blockSize
        self.fileSize       = fileSize
        self.contentType    = contentType
        self.contentSubtype = contentSubtype
        self.firstFreeBlock = firstFreeBlock
        self.lastFreeBlock  = lastFreeBlock
        self.freeBlockCount = freeBlockCount
        self.rootOffset     = rootOffset
        self.cachedVersion  = None
        self.dirty          = False

    def close(self):
        if self.dirty:
            print "Dirty, must write header."
            self.writeHeader()
        self.fileHandle.close()

    def writeHeader(self):
        buf = struct.pack("<9I", 0x00005442, self.blockSize, self.fileSize, self.contentType, self.contentSubtype, self.firstFreeBlock, self.lastFreeBlock, self.freeBlockCount, self.rootOffset)
        print "buf len:", len(buf)
        self.fileHandle.seek(0x12c)
        self.fileHandle.write(buf)
        self.dirty = False

    def version(self):
        if self.cachedVersion == None:
            versionFE = df.searchForFileEntry(0xffff0001)
            data = self.readDataFromBlocks(versionFE.offset, versionFE.size)
            self.cachedVersion = struct.unpack("<2I", data)[0]
        return self.cachedVersion

    def __str__(self):
        return "file: %s, blockSize: %u, fileSize: %08x, contentType: %08x, contentSubtype: %08x, firstFreeBlock: %08x, lastFreeBlock: %08x, freeBlockCount: %u, rootOffset: %08x, dataVersion: %u" % (self.fileHandle.name, self.blockSize, self.fileSize, self.contentType, self.contentSubtype, self.firstFreeBlock, self.lastFreeBlock, self.freeBlockCount, self.rootOffset, self.version())

    def readDataFromBlocks(self, offset, expectedLength):
        blockData = ""
        self.fileHandle.seek(offset)
        nextBlock = offset
        while nextBlock != 0:
            #print "nextBlock: %08x" % nextBlock
            if (nextBlock % self.blockSize) != 0:
                raise AC2Exception("Block offset %08x does not begin on a block boundary" % (nextBlock))
            if nextBlock < self.blockSize or nextBlock >= self.fileSize:
                raise AC2Exception("Block offset %08x does not fall within data area of file (%08x - %08x)" % (nextBlock, blockSize, fileSize))
            if (nextBlock & 0x80000000) != 0:
                raise AC2Exception("Block chain starting at %08x contains free block %08x" % (offset, nextBlock))
            nextBlock, = struct.unpack("<I", self.fileHandle.read(4))
            blockData += self.fileHandle.read(self.blockSize-4)

        if len(blockData) < expectedLength:
            raise AC2Exception("Data length (%lu) is shorter than expected (%u)" % (len(blockData), expectedLength))
        if len(blockData) > expectedLength:
            blockData = blockData[:expectedLength]
        return blockData

    def root(self):
        return AC2Directory(self, self.rootOffset)

    def searchForFileEntry(self, identifier):
        return self._searchForFileEntry(identifier, self.rootOffset)

    def _searchForFileEntry(self, identifier, offset):
        #print "Searching for %08x starting at %08x" % (identifier, offset)
        directory = AC2Directory(self, offset)
        while True:
            #print
            #print directory
            subdirIndex = 0
            searchLeftSubdir = False
            for fileEntry in directory.files:
                #print "%2u: Checking: %s" % (subdirIndex, fileEntry)
                if fileEntry.identifier == identifier:
                    #print "Found!", fileEntry
                    return fileEntry
                if identifier < fileEntry.identifier:
                    #print "check left, cur dir is", directory
                    subdirectoryOffset = directory.subdirectoryOffsets[subdirIndex]
                    if subdirectoryOffset == 0:
                        #print "%08x not found" % identifier
                        return None
                    #print "%08x < %08x, need to check subdirectory %u @ %08x" % (identifier, fileEntry.identifier, subdirIndex, subdirectoryOffset)
                    directory = AC2Directory(self, subdirectoryOffset)
                    searchLeftSubdir = True
                    break
                subdirIndex = subdirIndex + 1
            if not searchLeftSubdir:
                # Need to check the last subdir
                #print "Check last subdir"
                if len(directory.files) < len(directory.subdirectoryOffsets):
                    offset = directory.subdirectoryOffsets[len(directory.files)]
                    directory = AC2Directory(self, offset)
                else:
                    # Not found
                    break
        return None

    def readDataFromFileEntry(self, fileEntry):
        return self.readDataFromBlocks(fileEntry.offset, fileEntry.size)

    def addFreeBlocks(self, count):
        firstNewBlock = self.fileSize
        currentBlockOffset = self.fileSize
        blockData = "\0" * (self.blockSize - 4)

        # Need to update the last free block to point to the next, newly created free block
        if self.lastFreeBlock != 0:
            buf = struct.pack("<I", self.lastFreeBlock | 0x80000000)
            self.fileHandle.seek(self.lastFreeBlock)
            self.fileHandle.write(buf)
            self.fileHandle.write(blockData)

        # Now write the free blocks.
        for index in range(0, count):
            nextBlockOffset = 0
            if index < count - 1:
                nextBlockOffset = currentBlockOffset + self.blockSize
            if 1:
                print "Writing free block %4lu (@ %08x) to point to %08x" % (index, currentBlockOffset, nextBlockOffset)
            buf = struct.pack("<I", nextBlockOffset | 0x80000000)
            self.fileHandle.seek(currentBlockOffset)
            self.fileHandle.write(buf)
            self.fileHandle.write(blockData)

            lastBlockOffset = currentBlockOffset
            currentBlockOffset = nextBlockOffset

        if self.firstFreeBlock == 0:
            self.firstFreeBlock = firstNewBlock

        self.freeBlockCount = self.freeBlockCount + count
        self.fileSize = self.fileSize + count * self.blockSize
        self.lastFreeBlock = lastBlockOffset
        self.dirty = True

    def freeSpace(self):
        return self.freeBlockCount * (self.blockSize - 4)

    def ensureAvailableFreeSpace(self, length):
        if length > self.freeSpace():
            # Add more space to accomodate the data.  Add in 1 MB chunks.
            neededSpace = length - self.freeSpace()

            bytesPerExtension = ((1024 * 1024) / self.blockSize) * (self.blockSize - 4)
            extensions = math.ceil(float(neededSpace) / bytesPerExtension)
            count = int(1024 * 1024 / self.blockSize * extensions)
            if 1:
                print "Need %u bytes more." % neededSpace
                print "bytesPerExtension: %u" % bytesPerExtension
                print "extensions: %u" % extensions
                print "count: %u" % count
            self.addFreeBlocks(count)
            if length > self.freeSpace():
                print "Error: Failed to add enough data to data file. (%u required, %u available)" % (length, self.freeSpace())
        None

if 0:
    df = AC2DataFile("test/portal.dat")
    #print df

    print df.root()
    print "======================================================================"

    #fe = df.searchForFileEntry(0x41000000)
    #fe = df.searchForFileEntry(0x01000001)
    #fe = df.searchForFileEntry(0x0100001c)

    for identifier in [0x41000000, 0x41000002, 0x41000003, 0x41000004, 0x41000005, 0x41000006, 0x41000007]:
        fe = df.searchForFileEntry(identifier)
        print fe
        if fe:
            data = df.readDataFromFileEntry(fe)
            print len(data)
            filename = "out/%08x.dat" % identifier
            f1 = open(filename, "wb")
            f1.write(data)
            f1.close()

if 1:
    df = AC2DataFile("test/cell_2.dat")
    print df
    df.ensureAvailableFreeSpace(1024 * 1024 * 8)
    df.close()
    
